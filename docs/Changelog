Changelog - fatfs
C Hanish Menon <hanishkvc>
---------------------------

ToDo
-----
* Setting DevLBA register in 2 phase (ATA-2 specs say so)
  * 1st phase set only the DEV bit
  * 2nd phase also update the LBAAddr bits
* have to update fatfs->getfileinfo so that it doesn't convert the 16bit
  unicode to 8bit ascii.

06Dec2004
* Generalized bdh8b16.x.
* Fixed the dm270utils.h so that it uses PA_MEMREAD/WRITE routines
  instead of inw/outw, thus solving the stupid warnings because of
  change in definition of inw/outw between x86 and arm. This is also
  the right thing as in dm270(or inturn arm) i/o is memory mapped.

19Nov2004
* Added seperate PA_MEMREAD/WRITE8/16 routines and made BDHDD_READ/WRITE
  pick from these for MEM based BDHDD_ATA accesses. So that those parts
  of bdhdd.x which access non BDHDD_ATA registers use PA_MEMREAD/WRITE
  instead of BDHDD_READ/WRITE.
  This change required for devices which are interfaced improperly
  like say a bus with only 16bit addresses.
* Also added bdh8b16.x which allows accessing ATA devices connected
  to a 8bitData addressable host but with 16bitData Addresses on its bus.

11Nov2004
* Added support for MemCARD3PCtlr based CF access in some DM270 boards.
  However in the process found that the MemCARD3PCtlr seems to be depending
  on a synchronous transfer of data at a predefined (???) fixed rate.
  So for some EMIF CF Cycle timings it works for other either faster
  or slower it doesn't work. And even in the case where its working
  Its not consistent, as there is some loss of words inbetween.
  * Partialy ok behaviour is for => 0x1112, 0x0e07, 0x1331
  * Also reset using the DevCtrl bit doesn't seem to have much effect
  on MemCARD3PCtlr, as it returns telling success/failure but its state doesn't
  seem to change before or after this reset.
  * Also as words seems to be lost during the transfer, as far as MemCARD3PCtlr
  is concerned the transfer is finished before the host thinks so. So
  currently for the set EMIF CF timings a seccnt value of 160 seems to
  work. If its set beyond that then by the time the last sector is to be
  read by host, MemCARD3PCtlr is finished with data tranfer so it doesn't set 
  the DRQ bit, but rather becomes ready to recieve the next command. 
* If we set seccnt=1, then we get the best consistent reads. For each
  increase in seccnt, the consistancy of reads goes on falling.


07Nov2004
* Moved pakananosleep and starttime, stoptimedisp to linuxutils.x
  Updated files to follow this.
* Based on Profiles It seems like
  * 1MB databuffer based speeds are around 80%-94% of 4MB databuffer.
* Added support for testing readspeed of fatfs files using different
  databuffer sizes automatically.

06Nov2004
* Made the total cycle width less by 5 cycles. Not sure if writes
  will have a issue with this, as write is not yet implemented cann't tell. 
  Hope asking CFRDY to be checked would extend the CF cycles if required - 
  Have to cross verify.
* Profiles based on this update, STILL USING MANUAL STOPWATCH
  **** EMIF CF Cycle time => 0x0708 0x0401 0x1110 ****
  { BlockDev level tested using read of 80000 Sectors }
  { FatFs level tested using read of 160MB contiguous file }
  * For <Sandisk 1GB CF> [ PIO2, No APIO Info ]
    At BlockDev => 7.23-7.37 MB/Sec [4.25 MB/Sec]
    At FatFs    => 6.83-6.92 MB/Sec (4MB databuffer) [4.00 MB/Sec]
                   5.42-5.47 MB/Sec (1MB databuffer) [3.48 MB/Sec]
  * For <Transcend 512MB CF> [ PIO2, No APIO Info ]
    { This CF had many badsectors so that could be the reason
      for large diffs in speed  between different levels }
    At BlockDev => 5.35-5.58 MB/Sec [4.00 MB/Sec]
    At FatFS    => 4.38-4.40 MB/Sec (4MB databuffer) [3.48 MB/Sec]
                   2.63-2.64 MB/Sec (1MB databuffer) [2.23 MB/Sec]
  * For <Transcend 256MB CF> [ PIO2, No APIO Info ]
    { FatFS level used 60MB Fragmented file }
    At BlockDev => 5.35-5.50 MB/Sec
    At FatFS    => 5.08-5.18 MB/Sec (4MB databuffer)
                   4.22-4.25 MB/Sec (1MB databuffer)
  * For <Kingston 256MB CF> [ PIO1, No APIO Info ]
    { FatFS level used 7MB contiguous file }
    At BlockDev => 3.20 MB/Sec []
    At FatFS    => 2.66-3.00 MB/Sec (4MB databuffer)
                   2.66 MB/Sec      (1MB databuffer)
                   2.38-2.66 MB/Sec (256KB databuffer)
  * For <Sandisk 64MB CF> [ PIO1, No APIO Info ] >> SLOWEST FOUND TILL DATE <<
    { FatFS level used 8MB contiguous file }
    At BlockDev => 1.96-1.99 MB/Sec []
    At FatFs    => 1.61-1.80 MB/Sec (4MB databuffer) []
                   1.52-1.68 MB/Sec (1MB databuffer) []
                   ~same as above   (512KB databuffer) []
* Added support for extracting file to Standard Output in fileExtract menu
  if STDOUT is specified as the destination file. During this process
  found that the DM270 target uart seems to be lossing characters 
  once in a while.
* Added logic to calculate SIMPLE CHECKSUM of files either in the normal
  system filesystem or my fatfs filesystem.
  ON VERIFYING THE DATA INTEGRITY OF THE FILES READ USING FATFS AND
  FAST READ LOGIC BASED CF DRIVER of BDHDD.X, IT WAS FOUND THAT THERE IS 
  NO CORRUPTION OF DATA EVEN AT HIGH SPEEDS. THATS COOL.
* FIXME: Found that the reset logic is hanging on DM270 CFs, to verify
  as to where and fix it later.

04Nov2004, 05Nov2004-0100
* Note that the <Sandisk 1GB CF>, <Transcend 512MB CF> and 
  <Transcend 256MB CF> support upto PIO2 mode. 
  While the <Kingston 256MB CF> supports only upto PIO1.
  So the speed difference among them below
* Based on the profiles done as mentioned below EMIF CF Cycle times updated to
  **** EMIF CF Cycle time => 0x0c0d 0x0401 0x1110 ****
  * For <Sandisk 1GB CF>
    { Taking lower values got, as timing is sensitive and stopwatch manual }
    BlockDev level => 6.45MB/Sec [4.25 MB/Sec]
    FatFS level => 6.20MB/Sec (4MB databuffer) [4.00 MB/Sec]
                   5.00MB/Sec (1MB databuffer) [3.48 MB/Sec]
  * For <Transcend 512MB CF>
    BlockDev Level => 5.45MB/Sec [4.00 MB/Sec]
    FatFS level => 4.37MB/Sec (4MB databuffer) [3.48 MB/Sec]
                   2.63MB/Sec (1MB databuffer) [2.23 MB/Sec]
  * For <Transcend 256MB CF>
    BlockDev Level => 5.42MB/Sec
    FatFS level => 5.00MB/Sec (59MB FRAGMENTED file, 4MB databuffer) 
                   4.20MB/Sec (59MB FRAGMENTED file, 1MB databuffer) 
  * For <Kingston 256MB CF>
    BlockDev Level => 3.23MB/Sec
    FatFS level => 2.80MB/Sec Avg (4MB & 7MB files, 4MB databuffer)

  Note: For Small files the speed during 1MB databuffer tends toward 
        4MB Databuffer Speeds
  Note: In above data [xxxxx MB/Sec] corresponds to default EMIFCF CycleTimings

* Updated bdhdd.x logic such that the DM270CF logic is added
  only if PRG_MODE_DM270 is defined
* Made the Databufsize in the testfat.c definable for a given run
  of the prg within a set max limit. Useful for testing effect of
  Databuf size on speeds achieved.
* Profiled Data on DM270
  **** EMIF CF Cycle time => 0x0c0d 0x0901 0x1110 ****
  **** 160MB contiguous file (fatfs) and 40MB contiguous (blockdev) ****
  * For <Transcend 512MB CF>
    BlockDev Level => 5.14MB/Sec
    FatFS level => 4.11MB/Sec (4MB databuffer)
                   3.40MB/Sec (2MB databuffer)
                   2.53MB/Sec (1MB databuffer)
  * For <Sandisk 1GB CF> 
    { Taking lower values got, as timing is sensitive and stopwatch manual }
    BlockDev Level => 5.89MB/Sec
    FatFS level => 5.57MB/Sec (4MB databuffer)
                   5.23MB/Sec (2MB databuffer)
                   4.60MB/Sec (1MB databuffer)

  **** EMIF CF Cycle time => 0x1213 0x0f07 0x1110 ****
  **** 160MB contiguous file (fatfs) and 40MB contiguous (blockdev) ****
  * For <Transcend 512MB CF>
    BlockDev Level => 4.36MB/Sec
    FatFS level => 3.61MB/Sec (4MB databuffer)
                   3.04MB/Sec (2MB databuffer)
                   2.32MB/Sec (1MB databuffer)
                   1.50MB/Sec (512KB databuffer)
  * For <Sandisk 1GB CF>
    BlockDev Level => 4.65MB/Sec
    FatFS level => 4.42MB/Sec (4MB databuffer)
                   4.18MB/Sec (2MB databuffer)
                   3.77MB/Sec (1MB databuffer)

  **** Default EMIF CF Cycle time => 0x1415 0x1109 0x1220 ****
  **** 160MB contiguous file (fatfs) and 40MB contiguous (blockdev) ****
  * For <Sandisk 1GB CF>
    BlockDev Level => 4.25MB/Sec
    FatFS level => 4.00MB/Sec (4MB databuffer)
                   3.80MB/Sec (2MB databuffer)
                   3.48MB/Sec (1MB databuffer)
                   2.96MB/Sec (512KB databuffer)
 

03Nov2004-2350
* Added support for DM270 EMIF DMA between CF and SDRam
  Now getting on the Transcend 512MB CF
  at BlockDev level => 4MB/Sec (40MB contiguous data)
  at FatFS level => 3.48MB/Sec (160MB contiguous file and 4MB Databuffer)
                    2.89MB/Sec (2MB Databuffer)
                    2.23MB/Sec (1MB Databuffer)
  * Also enable compiler optimization, which would have helped 3 to 5 %
* DANGER: This seems better than the bootloader level and PrKernel level
  for FPMC and or Board24 or Board24MNC. HAVE TO VERIFY INTEGRITY of DATA READ.
  As of know ASSUMING INTEGRITY as Directory contents seem to be proper and 
  also as CFRDY is being checked by DM270 before accesing CF.

03Nov2004
* Added support for DM270 CF access
  * unrolling loop as helped speed here
  * Passing larger buffer to fatfs for reading file improved speed
  * declared some functions as inline, seems to have improved speed 
* Cleaned up code, which was already clean
* ON DM270 CF access (PIO mode, no 270 DMA, unrolled loop)
  <Using Transcend 512MB CF>
  Blockdev level speed = 1.48MB/Sec (40MB contiguous read to same buffer)
  For 160MB file (almost contiguous) read to same buffer of size
    4MB databuffer   => readspeed=1.32MB/Sec 
    3MB databuffer   => readspeed=1.28MB/Sec (vaguely remember, to retest)
    2MB databuffer   => readspeed=1.18MB/Sec 
    640KB databuffer => readspeed=810KB/Sec
* TOTRY to improve DM270 CF Speed
  * Use EMIF DMA to transfer data from CF to Memory instead of ARM.
    Note this is still PIO Mode as far as CF is concerned.
  * Currently using Default CS1 timings and explicit wait for CFRDY
    have to see if reducing cycle time helps get data without corruption
    * Also couple this with Changing PIO mode used for CF using SETFEATURE
  * Maybe move to kernel space (may not help much, as already 
    realtime scheduled)
* FIXME:
  * Found some issue with only chdir for some directories once in a while
    have to verify if reproducable on PC. Maybe some issue with FATUC
    logic have to verify

27Oct2004
* Made the blockdevices' setup routine to take a bdkT * as input and
  initialize its member rather than the previous predefined bdkT
  variable. Thus allowing more than one blockdev of a given type
  to be used at the same type.

InBetween
* porta library has been updated as part of another work
  
18Oct2004
* Added support for set features, but disabled by default
  Not much use on PC as the ioport access in the PC architecture
  is limiting the speed achieved to somewhere between PIO0 and PIO1
* Reduced the time the bdhdd.x waits after issuing a command
  before checking for BSY bit and other bits to around 500ns
  The spec talks about 400ns. But just in case
* Added ERROR_FATFS_NOTBOOTSEC 

15Oct2004
* Added support for READMULTIPLE logic in bdhdd.x and bdk.h
* More IDENTIFY DEVICE values displayed
* Added Realtime scheduling support for testfat.
  This has improved speed by 40-50%. 
  Previously getting around 2.xMBytesPerSec for bdhdd
  Now getting around 3 MBytesPerSec for bdhdd
* Added a new get_sectors_benchmark function for BlockDevs
  bdfile makes it NULL, where as bdhdd.x provides a modified get_sectors
  to get_sectors_benchmark where the dest buffer pointer is reset to
  begining of buffer after each sector is read. Thus one requires 
  a buffer of only 512 bytes irrespective of the number of sectors
  read during benchmarking

14Oct2004
* Added a option to partk_get to force interpretting a sector as MBR
  irrespective of it finds valid signatures or not.
  Useful if there are bootloaders like grub,etc in the MBR.
* fatfs bootsectorload logic updated to check for fatfs's usual
  bootsector signature in the first byte.
* testfat now allows user to 
  * force a BlockDev reset at the begining
  * force MBR interpretation by partk_get logic
* bdhdd as unrolled loop for get_sectors
* Updated utilsporta to support char16 strings required for FatFS LFN
* Updated fatfs.getfileinfo to work with both char and char16 string
  by passing useLFN flag as required. 
  fatuc uses 8.3 filename for its operations for now.
  Testfat prg also updated. Use 8.3 filenames as it cann't accept
  filenames with space in them for now.
  This required as many windows VFAT volumes don't have LFN entries
  for filenames which fit within 8.3
* testfat added a readspeed test function which reads from fatfs file
  into memory


12Oct2004
* Added logic to simulate error in loadfat for PARTLYMAPPEDFAT logic
  This inturn will lead to wrong sector number being passed to BlockDev
* Before a cmd is sent to HDD, its checked that BSY or ERR or DRQ bits
  aren't set. However if they are set then SRST (softreset) is used
  to recover the situation if possible.
* Softreset added for bdks
  bdhdd.x uses this.
  bdfile.x makes this a dummy.
  testfat provides option to call it explicitly if required.
* bdfile.x 64bit seek added for large filesystems

11Oct2004
* Support for Mapping FAT into memory in parts as required has been added
  Now there are two FAT loading logic
  * Fully Mapped and * Partly Mapped (Usefull for those large FAT32 FATS)
* bdhdd.x uses altstat register to poll status changes and once found
  reads the status register to inform h/w about host having noticed
  the status change.
  Verification of DRQ during each word transfer (if explicitly forced)
  has been removed
* Check for MBR Startbyte signature as been made optional in partk_get
  cas many mbr's which don't have a load code (or which don't take part
  in bootstrapping of OS) don't have this signature, as its part of the
  load code instructions.
* bdhdd.x cleanup and better error notification
  Also increase in wait counts
* partk_get distinguishes between other errors and NO MBR error
  mount inturn uses this info to decide as to fail or continue
  

10Oct2004
* Made bdhdd.x generic such that it can work with either ide0 or ide1
* bdhdd.x has timeout logic now when waiting for bits to be set or cleared
  Plus few others make it better prepared to handle errors during device
  access
* bdkT maintains 
  * grpId and devId, which
    * bdhdd.x uses for ide0/1 and dev0/1
    * bdfile.x ignores
    fsutils and testfat updated to handle these ids.
  * CMDBR and CNTBR for bdhdd.x for now

09Oct2004
* Found that READSECTORSWITHOUTRETRIES (0x21) not supported
* Also signature in LBAlow, LBAMid, LBAHigh, DEVLBA24, SECCNT not set
  for IDENTIFYDEVICE in Bochs, VMWare
* Updated get_sector logic such that it supports multiple sectors to be 
  read properly even if it exceeds 256 sectors.
  However currently it doesn't handle errors or buggy hardware properly

08Oct2004
* Initial support for get_sector, a simple mistake in code debugged

07Oct2004
* Started preliminary support for PC based HDD (bdhdd.x)

05Oct2004
* Added function pointers to TFat structure so that during fatfs_init
  Proper functions are assigned to these pointers depending on the
  FATFS type i.e 12 or 16 or 32. And thus other parts of the fatfs
  logic are not required to bother about the fatfs type. This is
  the best flexible mechanism that can be put in place other than
  having seperate hardcoded fat12/fat16/fat32 type functions.
  * The low level functions are
    * Loading root dir 
    * Getting a Fat Entry
      * FIXME: In future we can make the FAT table handling flexible
        i.e Either Full FAT table could be in Memory or we could load
	parts of FAT Table as required by updating this function.
        - FIXED around 11Oct2004
  * Updated other parts so that they use this mechanism
* Added support to check BlockDev sector size matches FatFS sector size
* Partiton or Physical volume size is embedded in TFat structure and 
  verified to see that FatFS bootsector doesn't tell that FatFS exceeds
  this.
* active Fat Table is identified for Fat16(implicitly 0) and Fat32(extflags)
* Added support for Fat32 read, directory listing, chdir etc except 
  Write operations(same status as Fat16).  Achieved by providing support 
  for fatfs32_getfatentry and fatfs32_loadrootdir, using simplified 
  generalized mechanism added today.
* Logic to autodetect possible Fat32 FS in a small volume suitable for
  Fat12 or Fat16 added.
* Check for and avoid working on Volume with DiskI/O error during last mount
  or Volume which wasn't Cleanly shut.

04Oct2004
* cycle to stars continues
* Removed the nonportable but fast macros for accessing members 
  of the bootsector.
  These are nonportable as there are fields with wrong alignment (based on
  field size) which processors like ARM/Mips don't support in h/w but would
  require s/w support in OS.
* Partition logic identifies if it has a MBR at hand
  Also it uses a buffer passed to it to read the 0th sector into.
* mount and umount added

30Sep2004
* Incorporated new porta libraries into fatfs
* Made blockdev data and routines into a structure so that it can be
  embedded into Fat structure. Also now a given Fat system could be in 
  any among the many blockdevs in the system.

22july2004
* Made testfat functions use uc pointer as one of their arguments.
  So that we can test/work with multiple fat filesystems in a given run.


21july2004-2200 (what I remember now)
* Interactive menu added to testfat
* Partition support in loadfile functions (i.e adding used partitions baseSec)
* Updated the logic such that they no longer use global structures instead 
  * all fatfs calls use a TFat structure which inturn gets its buffers
    set from a TFatBuffers structure defined by user.
  * and all fatuc calls use the TFatFsUserContext structure which inturn
    as a pointer to the TFat it is using.


20july2004-2300 (what I remember now)
* Added support for reading files with clusSize granularity (loadfileclus).
  Also a separate function is provided so that the application can verify 
  if the buffer it has is ok with this loadfileclus function.
* Added some utility functions for strcpy, memcpy, token parsing
* current path string is maintained in UserContext
* each logic of testfat is timed with added helper routines
* File extraction logic added to testfat
* new dirlisting (inefficient(toShowOthersHowItCouldBe)) logic added



ToDo
------
* Remove the forced Unicode to Ascii string conversion in getfileinfo
  and provide routine to convert given ascii string to unicode, so that
  we can always maintain unicode string in lfn of TFileInfo.

