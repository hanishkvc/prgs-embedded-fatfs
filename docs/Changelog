Changelog - fatfs
C Hanish Menon <hanishkvc>
---------------------------

ToDo
-----
* Setting DevLBA register in 2 phase (ATA-2 specs say so)
  * 1st phase set only the DEV bit
  * 2nd phase also update the LBAAddr bits
* Have to update the totSecs in bdkT structure from bdhdd.x and bdh8b16.x
* In fatuc_move_dentry if a directory is being moved to a new location
  see to it that you update its parent directory entry(..) to correspond
  wrt the new location where it is.

27Apr2005
* Added support for maintaining and tracking the count of freeClusters in 
  the filesystem. However this freeClusters count could be UNKNOWN/ GUESSED/
  KNOWN. If the freeClusters is found as part of building the fat->freeCl
  OptimizedFreeClusList logic then it will be a GUESSED value as it doesn't 
  necessarily find all the free clusters in the filesystem. If it is found
  using the fatfs_update_freeclusters logic then it is proper KNOWN value.
* Also updated the file deletion and file writing logics, rather those parts
  of these logic which directly manipulate the FATTable to also update this
  new freeClusters count of fat structure in memory.
* fatfs_update_freeclusters uses accessPattern support to be more efficient.
* FIXME: Am not accounting for a single cluster as part of freeClusters cnt
   when deleting file. Easy to fix but lazy for now.
* On mounting this freeClusters count might get a GUESSED value assigned as
  part of the OptiFreeClusList building logic provided there are freecluster
  chunks of sufficient length as searched by the logic.
  If required User can force the fatfs logic to assign/initialize the proper
  or in other words KNOWN value by explicitly calling fatfs_update_freeclusters
  or fatuc_getfreeclusters. 
  However if the user is just interested in knowing the current value 
  maintained by fatfs logic then he can call fatfs_get_freeclusters or 
  fatuc_approx_getfreeclusters.
* FIXME/NOTE: May add a flag to fsutils_mount to decide whether to leave
  the freeClusters cnt at the GUESSED level or put a proper/KNOWN value.
* Updated testfat.c to use the new fatuc_[approx_]getfreeclusters logic.
* Fixed a corner case issue with __getoptifreecluslist which was recording 
  any freeclus chunk too near to begining of the filesystem into oblivion 
  (god knows where in memory???). 
  This could also have been the reason has to why the fatfs logic was searching
  for freecluster chunks too quickly sometimes. Especially easily noticed in
  large harddisk partitions.
* NOTE/FIXME: When writing a file into filesystem if it runs out of disk space,
  this file could have some corruption. This issue can be fixed by checking if 
  the FATTable cluster being written into or assigned to a file is free or 
  already assigned. However as this would slow the write logic a bit, i mean a 
  small bit I am not currently taking care of this. There Could also be a 
  situation where the last few relatively small files written into a filesystem
  running short of disk space is corrupted/overwritten by the newer files.
  *Another way to avoid this is by seeing to it that the optifreeclus list does
  not contain any overlaps.
* When the FS has run out of space almost, even if a file is deleted to release
  space back to the FS. This space was not being used to allocate to newer 
  files unless we explicitly remount the FS. This issue has been fixed by 
  updating the fat->freeCl.curMinAdjClusCnt from within __addto_freeclusters
  when required.
* Fixed the error message display logic in fsfreelist logic of testfat.c

22Apr2005
* Added support for Hinting to partlyMappedFATtable logic about 
  access patterns in the filesystem. i.e whether the accesses are
  going to be 1) Only Forward 2) Mostly Forward or 3) Balanced (i.e
  bothr forward and backward access is equally likely)
* The update_freecluslist logic uses this above flexibility to specify
  or hint to fs that Its going to do FATFS_ACCESSPATTERN_ONLYFORWARD 
  kind of access.
* Also updated this optifreecluslist logic such that initially it
  searches for (fsPartitionSize/32) size free chunks. And later
  during each subsequent scan thro the FAT table it searches for
  free chunks whose size are only 1/4 of that during the previous 
  search. This should make the FatFs optiFreeClusList logic more
  friendly for large partitions like (4GB or so).
* Even applications can use the new hinting mechanism to inform fs as 
  to they are going to only move forward in files or only backwards
  or both ways is possible. Assuming that Files generally are going to 
  be placed such that as one moves forward in a file, the corresponding 
  data will be placed such that the logical address in the fs increases.
  This hinting should help make fs metadata management more efficient.

18Mar2005
* InBrief
  * Fixed fatuc_move_dentry such that it takes care of putting LFN
    if available into dentries of the file.
    * As part of this fixed a issue with fInfo.[f|l]DEntryPos not 
      being initialized to actual values during creation of a new
      file.
    * Fixed the bug where fInfo.lDEntryPos was being set to one dentry 
      beyond the actual last dentry of a file in fatfs_getfileinfo

17Mar2005
* InBrief
  * Updated all logic related to block devices (bdkT) such that they
    accept a generic bdkFlags during initialization, instead of the
    specific reset flag. Through this bdkFlags one can specific as
    of now 
    (1) reset during initialization 
    (2) keeping device bus slow
    (3) doing read of block device one sector at a time.(as of now
        write using, single sector at a time, is not supported as user
        will be forced to use this BDK_FLAG_SECSINGLE only if blockdevice
        is not behaving properly)
    * Also updated testfat to query for these 2 new flags before running
  * Configured h/w to avoid checking of CFREADY during access of MemCARD3PCtlr 
    chip connected thro CF. Because MemCARD3PCtlr goofs up when CFREADY check
    is enabled.
  * Added logic to take care of situation when fatuc_move_dentry is 
    provided with u16Name. 
    * As part of this a proper 8.3 name is derived and stored in UPPERCASE
      as required by fat.
  * Also made fatuc__getfileinfo more foolproof by checking if path of
    the file being checked is ".\" and if so automatically use current 
    directory as "." corresponds to current directory. (Otherwise, both
    the dir buffers would have pointed to current directory and thus
    goofed up things)

11Mar2005
* InBrief
  * Added support for mkdir
  * fixed a issue with FN83_expand when the name given is exactly 
    8 chars long
  * updated updatefileinfo_indirbuf so that it also saves Attribute 
    and wrtDate and wrtTime to as required disk.
  * added logic to calculate the chksum stored as part of direntries
  * Updated the new directory entry creation logic such that it 
    creates free dentries infront of 8.3 name entry so that if
    longfilename requires to be assigned there is space readily
    avialable.
  * Added support for moving file/dir. However currently it doesnot
    handle Long File Names.

01Mar2005
* InBrief
  * Completed the caching logic for FreeClusList in TFat
    Its been implemented to balance between speed/time and space.
    Also care has been taken that while mounting, it attempts to
    build this cache only once, that too for large chunks of
    freeclusters.
    This should improve the write speeds a lot especially for
    large FAT32 partitions under FAT_PARTLYMAPPED conditions
    (with lot of fragmentation in filesystem on top of it OR
     even with hardly any free clusters at the begining of partiton
     (which is very possible)) cas previously this would have led to 
     going thro the fat table trying to find free clusters each time
     fatfs__storefileclus logic was called.
  * Added a few comments for existing logics so that the intricacies
    are quickly recognisable in future if required to modify some things.
  * fatfs__storefileclus fixed wrt the case when actually the file is 
    written to disk (with new free clusters used to write data to file
    or data written till end of file) but it returns ERROR_UNKNOWN.
    This would have occured rarely (only if no free clusters available 
    in partition) in the old logic (i.e without freecl cache) But would
    be triggered always when endoffile is reached while writing to file
    (or into a new file) with the new freeCl cache based logic. As it
    returns cl to fatfs__storefileclus such that it contains only so many
    freeclusters as required currently.
* WARN: For a given FatUC if one is writing into a newly created file
  then don't upset FatUC's dirBuffers(or specifically the dirBuffer holding
  the metadata of this newly created file) by doing any operations like
  chdir or opening other files in a different directory unless you have 
  closed or synced the newly created file.

28Feb2005
* InBrief
  * Added initial support to maintain a OptimizedFreeClusList in TFat
  * fatfs__storefileclus uses this Optimized Cluster List
    thus reducing the scanning of FatTable for free clusters
    considerably.
  * Removed the logic to strip library of symbols as a library
    without symbols cann't be used.

17Feb2005
* InBrief
  * Fixed the FileHandle loss issue in fopen
  * Fixed a issue with deleting empty files
  * Added file creation support
  * Updated testfatxxxx.x routines to use filedeletion 
    and filecreation support added to fatfs.
  * fatfs->getfileinfo updated to store unicode as unicode 
    for longfilenames.
  * updated some rwporta routines

16Feb2005
* InBrief
  * Fixed the issue with writing to empty files in filesystem.
  * Added support for file deletion.
  * Support routines for file creation added
  * Found a possible FileHandle loss in rare cases - to be fixed.

07Feb2005
* Moved the dm270 related logic added to bdhdd.c and bdh8b16.c 
  to dm270utils.c. So that all dm270 related logic is restricted to
  dm270utils.x and others (bdhdd.c and bdh8b16.c) contain only
  reference to the dm270utils.x. 
  * The moved logic are
    * init logics - dm270cf_fpmc, dm270cf_MemCARD3PCtlr, dm270ide_h8b16
    * dma routines to move between sdram and cf and sdram and emif(ide)
* SIMPLY LIKE THAT Added support for ATA Write to bdh8b16.x 
  by moving from bdhdd.x
  * put_sectors
  * outswk simple,unrolled and dm270dma
  UNTESTED for now, have to do it maybe tomorrow

04Feb2005 
>> Made fatfs a library explicitly atlast, 
   previously it was a library only implicitly <<
* Updated Makefile to create a library of fatfs files and then
  compile testfat using this library
* Moved the bdxyz_setup definitions of the builtin blockdev drivers
  to bdk.h instead of the driver specific header files. Thus the
  application using blockdev drivers needs to include only bdk.h
* created a release entry in the makefile so that it copies
  * libfatfs.a libraries
  * header files (porta, blockdev, fatfs)
  * testfatxyz.xyz files - test program for the library
  * Makefile for library usage
  files to the release directory.
* Rationalized the bdh8b16 delay timings

03Feb2005
* Updated bdh8b16.x so that
  * If error is found during disk access it is repeated n times before
    giving up. 
  * Check for bits of altstat has nanosleep intermixed so that the
    host doesn't continuously bombard device with register access
    cycles.
  * checkstatus now has logic to explicitly wait (obviously with timeout)
    for DRQ to be set if the checkstatus was requested for a command 
    involving data transfer.
    * As a result even sendcmd requires to be told whethere a datacommand
      is being specified or not.
  Done to handle devices which are connected on a bus with race which leads
  to a lot of errors.
  HAD to delay ChipEnable signal so that address stabilizes. This solved
  the Race mentioned above(0x5111).
* Updated testfat.c blockdev read speed check logic such that it even
  works for blockdev drivers which don't have a seperate get_sectors_benchmark
  routine.
* Also updated bdh8b16.x so that
  * It uses EMIF DMA for DM270
  * Uses MultiSector read where available.
  * Reduced the EMIF Cycle timing, thus speeding up access(0x2234).
  * Speed as of now
    7.23MB/Sec for 145MB file using 4MB databuffer
    11.82MB/Sec for 65MB file using 4MB databuffer
    04Feb2005>>Oops speed should be around 8.2MB/Sec only and not 
    11.82MB/Sec as the 65MB file given in HDD was only 45MB in size.

01Feb2005
* Added write support for ATA devices
  * bdhdd_put_sectors
  * bdhdd_outsw routines simple, unrolled and dm270dma
* Add routine for blockdev write speed check
* Fixed some compiler warnings triggered by the older compiler
  * flagSpecialCurOrPrev and two successive ;;
* Increased the arm-elf- binary's stack to 256KB

31Jan2005
* __storefileclus updated wrt
  * fInfo->updated flag being set (stupidly optimized out yesterday and 
    then adding a goto which bypassed the optimized setting of this flag)
    after fInfo->newFileSize is updated due to writing of file data into
    new clusters.
  * fromClus being set for all cases of bAllWriten once the logic 
    enters the Allocate new clusters for the file case. This was the intention
    even yesterday but was some how missed out while putting the logic.
* storerootdir and storefat updated such that they don't write beyond their
  respective boundries as required. Added fat->curFatEndSecAbs to help with
  storefat so that it knows the FATTable boundry. Using fat->rdSize for the
  case of storerootdir.
* fsfreelist of testfat.c updated to display the total free space in the
  filesystem.

30Jan2005
* Had forgotten to save the updated FATTable back into block dev after 
  a file had been modified such that its FATTable entries were modified.
  *To support this and other FATTable modifications a flag fatUpdated
  was added to the TFat structure. And fatfs_storefat routine added
  and called from fatfs_loadfat (required for partly mapped fattables)
  and fatfs_cleanup.
  *fatfs_setfatentry logic updated to set the fatUpdated flag 
  if FATTable is updated.
  *Another entry curFatStartSec also added to TFat which is used 
  by fatfs_storefat
  * FIXED: While saving FATTable to block dev, have to see to it that 
    I don't write beyond the FATTable, cas currently nSecs to write
    is calculated blindly using the FATFAT_MAXSIZE, which is ok for
    loading but not for storing. << FIXED_31Jan2005
* Generic fatuc routines __getdirbufoffile and __savedirbuf added
  which are used by fatuc__syncfileinfo for now. Later when routines
  like deletefile, renamefile etc are added even they could use these.
* Have also added support for saving rootdir back to block dev if it 
  has been updated. This is triggered as part of fatfs_cleanup.
  * FIXED: While saving rootDir to block dev in Fat32, have to see to 
    it that I don't write beyond the rootDir, cas currently rootDir
    size is hardcoded to FATROOTDIR_MAXSIZE while calling __storefileclus, 
    which is ok for loading but not for storing. << FIXED_31Jan2005
* fatfs__storefileclus_usefileinfo had a issue with writing till EOF
  or beyond wrt to the fromClus, as fromClus would be invalid. This
  has been fixed by adding a special interpretation of fromClus value
  FATFS__STOREFILECLUS_FROMCLUS_ALLOC, which tells the logic that
  fromClus doesn't contain a valid cluster of the file and that it
  should allocate new clusters to the file and append it to its end.
  FIXED: Should have been handled now, with the changes I have done but
  still have to cross verify once again. << FIXED_31Jan2005_ISN'TIT
  Also a Issue with fileSize which is a non multiple of clusSize and 
  writing till EOF which results in wrong newFileSize has been fixed.
* As already mentioned fatfs_cleanup now calls fat->storerootdir and
  fatfs_storefat to take care of write support added to the filesystem.
* FIXED: Also Changes to a file in RootDir is requiring that this be
  done twice (as of now tested over two different sessions)
  before it gets updated in block dev for future use.
  FIXED_31Jan2005: Fixing the storefat to store only the FATTable and 
  nothing more seems to have fixed this bug AS WAS INTELLIGENTLY GUESSED.
* In fileextract2fatfs of testfatuc.c a small correction made so that
  source file gets opened first and then the destination file, thus
  directory containing the destination file will be available as part
  of FUC dirBufs.

29Jan2005
* fatfs__storefileclus_usefileinfo: Added support for writing cluster aligned 
  data to a already existing file.
  It takes care of both the case where the file is written into existing part
  of file as well as the situation where the file is being appended to (i mean 
  written following/beyond the current end of file).
* fatfs__syncfileinfo takes care of udpating any changed file info (currently
  changed filesize (due to write into file)) in to the corresponding directory 
  provided this is (1)the current directory or the (2)directory in tempdirbuf 
  of FUC or (3)the root directory. 
  Support for updating directory even if its non of the 3 situations mentioned 
  in previous line requires to be added << FIXME
  This inturn is used by fatuc_fclose if it finds that the fInfo.updated flag
  is set, thus updating the fs in the block dev.
  Note1: for rootdirectory it doesn't save the status back into disk - 
  to be done in fsutils_umount. << FIXED_30Jan2005
  Note2: Also in future fatfs__syncfileinfo should take a flag specifying
  what and all of the fInfo has been updated and then update all the 
  corresponding entities in the directory entry for the file. << FIXME
* MANY THINGS HERE TO document LATER, better go to sleep now.
  >> THEY HAVE BEEN DOCumented on 31Jan2005. <<
* Also update fatfs_getfileinfo_fromdir to understand the expanded
  8.3 File name stored as part of TFileInfo. Also a limitation 
  of this routine interms of restriction on the dirBufSize passed
  to it has been removed.
* bdk.h and bdfile.x updated with put_sectors command required
  for filesystem write support.
* clusSize calculated during loadbootsector and stored as part of TFat 
  structure. Similarly count of data clusters is stored in cntDataClus.
* RDUpdated flag added to TFat so that if root dir (entries) is updated
  this flag is set to indicate to fatfs_cleanup to take care of saving
  the root dir back to underlying block dev.
* Similarly TFileInfo gets
  * newFileSize used by the file write routines to indicate the new file 
    size after any writes. Which inturn will be saved back to block dev
    when file is closed.
  * updated flag used to tell that this instance of TFileInfo structure
    as updated data in it which requires to be updated into the 
    corresponding directory where this file lives. And then saved back
    to block dev. File write routines will set this flag when writes
    go beyond the existing EOF and the filesize is needed to be increased.
* fatfs32_setfatentry also added. Also as these setfatentry routines are
  accessed thro a generic fat->setfatentry mechanism, they are needed to
  convert special fat entries like EOF and BADCluster (specified using
  generic defines) into their(fat16 and fat32) respective value and then
  store into FATTable.
* in getoptifreecluslist routine MAYBE we should check for freeclusters 
  till cntDataClus+2, as DataClus 0 and 1 are special and not part of
  this cnt<RIGHT ???>. As this is non critical and doesn't affect integrity
  of the system, we use the safe value of cntDataClus itself.
* Added fatfs__getlastClus_usefileinfo to get the last cluster associated
  with a file.
* Added fatfs__linknewsegment_usefileinfo to added a new set of contiguous
  clusters to a specified cluster in the file (this is used by the __store
  fileclus routine and there this specified cluster will be the last cluster 
  of the file).
* fatfs_updatedfilesize_indirbuf updates the fileSize of the given filename
  in the given dirBuf.
* Removed util_strcpy and util_memcpy logic. Access to these had been replaced 
  by pa_strncpy and pa_memcpy sometime back.
* fatuc__changedir and TFatFsUserContext updated such that along with cur and
  temp DirBufs there is also a cur and temp DirInfo which stores the TFileInfo 
  data for the current and temp directory buffers maintained in the FUC. 
  Actually as it stands now instead of wasting space for a full TFileInfo
  structure to represent the directory info we could have even done with
  just the Directory's firstClus.
  This modification was done so that when files/directories get updated
  they can be propagated back to the fs in the block dev.
  For this same purpose even fatuc_getfileinfo renamed to fatuc__getfileinfo
  and updated to retrieve and assign this DirInfo into the new dInfo pointer 
  passed to it. Now fatuc_getfileinfo is a wrapper to fatuc__getfileinfo where
  the dInfo retrieved is dropped.
  This dInfo retrieved by fatuc__getfileinfo in addition to fInfo is used
  by the fatuc_fopen routine to store the dInfo as part of the new dInfo
  member added to TFatFile.
* testfatxxx updated such that there is support for fatuc based
  (a) copying file from fatfs to a local posix filesystem[cpfp] and
  (b) copying file within fatfs[cpff]. i.e from fatfs to fatfs 
      (using the new file write support added)
* pa_printints, pa_printuints, pa_printhexs added to utilsporta so
  that now while printing a integer we can also print a associated
  text string to follow the integer.


28-29Jan2005
* Made BDHDD_SECCNT_USE to 256 from 1
  This had been set to 1 during testing of MemCARD3PCtlr chip, which had problem
  working with more than a 1 sector(or maybe few) at a time if CFRDY was set.
  This inturn had brought the speed of blockdev (inturn) file access down
  to a great extent(around 50% or more).
* Added initial support for fs write
  * Added fatfs_getoptifreeclustlist function to retrieve the list
    of free clusters in the filesystem
  * Added fatfs16_setfatentry
* Updated testfat
  * Made the menu take words like ls, cd, cp, fsfreelist, etc
    instead of the previous single letters as commands. Thus 
    making the menu triggering more sensible.
  * Also added support for getting the fsfreelist
  * updated prevClus's to fromClus

27Jan2005
* Renamed the prevClus of TFatFile structure to the proper name of fromClus
  so also updation to offInFromClus. These variables correspond to the fPos
  of the file and tell the cluster from which data as to be read wrt current
  fPos and the offset within this cluster.
* Cleaned up fatuc__fposChangedUpdate
  * removed forceUpdate, now when ever this is called it will update
    the metadata(fromClus,offInFromClus) if required.
  * logic to decide resetFromClus moved in rather than being calculated 
    outside and then passed in. This is possible now as the oldFPos 
    (to which fromClus and offInFromClus correspond to at the begining 
    of this call) as well as the new fPos are available to this function.
* Added a routine to testfatuc.c to help test fatuc_fseek. And a associated
  helper script to verify if fseek succeeded <script is hardcoded to the
  rand4.log file generated by the Makefile as part of fileBasedBlockDev file
  creation and then copied to /tmp directory>. To better test the logic
  the seek offsets are randomly generated. For this my portable random
  number generator is used.

26Jan2005 - Indian Republic Day
* Fixed the issue with bytesRead returned being slightly larger than
  the actual file data (because of padding bytes at the end to
  fill the fs cluster) when fatuc_fread is reading the data at the
  end of the file.
* Fixed the updation logic for meta data associated with fpos such that
  for the common case it is fast and especially in case of fatuc_fread 
  its no longer required to call the fatuc__fposChangedUpdate function. 
  *To achieve this I have update fatfs__loadfileclus_usefileinfo function 
   (well fatfs_loadfileclus_usefileinfo as been renamed to this, as its updated 
   to return one more argument as well as its arg names  made non ambiguous.
   While the orig fatfs_loadfileclus_usefileinfo named function is now just a 
   wrapper around this __ version and inturn ignores this new argument returned) 
   such that it returns not only the fromClus for next call to it, but also the 
   lastClusRead during the current call.
  *Also if the fPos as moved forward and not back, it doesn't get the OCL
   from the begining of the file, but only from the last fPos before the 
   seek which moved fPos forward.
  Because of these changes its no longer critical to have a OCL buffer
  in TFatFile structure. However having one would still help interms
  of avoiding unnecessary load of FATTable parts when FAT_PARTLYMAPPED logic
  used, but with the associated limitation in the number of fragments
  supported for any given file. << MAYBE FIXME <<
* Fixed a small bug in fatuc__fposChangedUpdate wrt when TFatFiles prevClus
  gets set to 0. 
* Also made the testfatuc.c's readspeed logic trigger unaligned accesses

25-26Jan2005
* Updated the fatuc_fseek and fatuc_fread support such that the check for
  unaligned fpos (wrt cluster) and its associated updation of meta data
  required to achieve proper block level access is done only when required
  rather than always (as done in previous release). 
  * FIXED(26Jan2005): However still there is a issue interms that each time a
    unaligned access is done all the FATTABLE entries associated with
    the current file is accessed, which will be detrimental wrt speed
    when FAT_PARTLYMAPPPED logic is used(normal for Fat32) and a file's
    FATTABLE entries cross over the PARTS of the FATTable.
    * A simple and fast solution is to have space set aside for the
      optimized cluster list(OCL) in the TFatFile structure and have 
      fatuc_fopen fill this up once so that all subsequent reference 
      to OCL can use this info in memory rather than having to go back
      to the Fat FileSystems FATTable.
* Hadn't handled FULLY the case where user requests for more data than
  what is in the file by using wrong bytesToRead. This would still
  read the proper amount of data but would have returned ERROR_UNKNOWN.
  This has been fixed partialy now. Now it identifies if user has
  asked for more data than what is available in the file and then
  returns success. HOWEVER STILL currently the bytesRead returned by
  fatuc_fread also contains the padding bytes at the end of file to
  fill the cluster. FIXED(26Jan2005): This HAS TO BE FIXED by updating bytesRead 
  returned such that it only contains the actual bytes read from file 
  and not these padding bytes.
* Also updated testfatuc.c file such that for checksum calculation
  and for file extraction it makes requests such that the fPos will
  be unaligned wrt cluster boundries.
  FIXME: Have to fix the case where the time and speed calculation
  logic goofs up if the function being timed returns too fast and the
  system inturn as clockskew or no time as elapsed between the function
  call(currently it will kill the program as a divide by zero execption
  is raised).

18Jan2005
* Added support for fatusercontext based file open, seek, read and 
  close for now. 
* Currently its a lazy logic, which recalculates the active entities
  each time read is called. May split the logic such that the 
  active entities depended on filePos is calculated only if required
  like during seek operations and after read operation if the filePos
  doesn't end at a Cluster boundary.
* For the above, updated the TFatFsUserContext such that it has
  space for meta data of a given number of Fat files like the 
  TFileInfo and filePos. 
  And all the fatuc_fxxxx functions use handles to these metadata
  to handle the fat files and thats what the end user works with
  also at the end.
* Changed fatuc_changedir to fatuc__changedir as this is a internal
  routine to be used by other fatuc_xxxxx functions and not to be
  directly called by the user.
* Maybe some other chota mota things in between these days
* As a result of above added testfatuc.c file with routines based
  on the fatuc_fxxxxx functions.
* Also as of now I have done only very minimal tests for the new
  fatuc_fxxxx functions, that too those tests which test that
  the previous functionality is not lost to some extent.
  More thorough tests to be done. Also As I had to upgrade/downgrade
  the Linux in my system, the arm-elf-xxxx cross tools which I had
  compiled previously don't work on this new system as it requires
  a newer libc library. So till I haven't fixed this up one way 
  or other, I cann't do any target based testing.
* YET To test the full functionality and the speed hit with these 
  new fatuc_fxxxx routines.


06Dec2004
* Generalized bdh8b16.x.
* Also found that MemCARD3PCtlr chip doesn't work properly when CFRDY  
  check is enabled.
* Fixed the dm270utils.h so that it uses PA_MEMREAD/WRITE routines
  instead of inw/outw, thus solving the stupid warnings because of
  change in definition of inw/outw between x86 and arm. This is also
  the right thing as in dm270(or inturn arm) i/o is memory mapped.

19Nov2004
* Added seperate PA_MEMREAD/WRITE8/16 routines and made BDHDD_READ/WRITE
  pick from these for MEM based BDHDD_ATA accesses. So that those parts
  of bdhdd.x which access non BDHDD_ATA registers use PA_MEMREAD/WRITE
  instead of BDHDD_READ/WRITE.
  This change required for devices which are interfaced improperly
  like say a bus with only 16bit addresses.
* Also added bdh8b16.x which allows accessing ATA devices connected
  to a 8bitData addressable host but with 16bitData Addresses on its bus.

11Nov2004
* Added support for MemCARD3PCtlr based CF access in some DM270 boards.
  However in the process found that the MemCARD3PCtlr seems to be depending
  on a synchronous transfer of data at a predefined (???) fixed rate.
  So for some EMIF CF Cycle timings it works for other either faster
  or slower it doesn't work. And even in the case where its working
  Its not consistent, as there is some loss of words inbetween.
  * Partialy ok behaviour is for => 0x1112, 0x0e07, 0x1331
  * Also reset using the DevCtrl bit doesn't seem to have much effect
  on MemCARD3PCtlr, as it returns telling success/failure but its state doesn't
  seem to change before or after this reset.
  * Also as words seems to be lost during the transfer, as far as MemCARD3PCtlr
  is concerned the transfer is finished before the host thinks so. So
  currently for the set EMIF CF timings a seccnt value of 160 seems to
  work. If its set beyond that then by the time the last sector is to be
  read by host, MemCARD3PCtlr is finished with data tranfer so it doesn't set 
  the DRQ bit, but rather becomes ready to recieve the next command. 
* If we set seccnt=1, then we get the best consistent reads. For each
  increase in seccnt, the consistancy of reads goes on falling.


07Nov2004
* Moved pakananosleep and starttime, stoptimedisp to linuxutils.x
  Updated files to follow this.
* Based on Profiles It seems like
  * 1MB databuffer based speeds are around 80%-94% of 4MB databuffer.
* Added support for testing readspeed of fatfs files using different
  databuffer sizes automatically.

06Nov2004
* Made the total cycle width less by 5 cycles. Not sure if writes
  will have a issue with this, as write is not yet implemented cann't tell. 
  Hope asking CFRDY to be checked would extend the CF cycles if required - 
  Have to cross verify.
* Profiles based on this update, STILL USING MANUAL STOPWATCH
  **** EMIF CF Cycle time => 0x0708 0x0401 0x1110 ****
  { BlockDev level tested using read of 80000 Sectors }
  { FatFs level tested using read of 160MB contiguous file }
  * For <Sandisk 1GB CF> [ PIO2, No APIO Info ]
    At BlockDev => 7.23-7.37 MB/Sec [4.25 MB/Sec]
    At FatFs    => 6.83-6.92 MB/Sec (4MB databuffer) [4.00 MB/Sec]
                   5.42-5.47 MB/Sec (1MB databuffer) [3.48 MB/Sec]
  * For <Transcend 512MB CF> [ PIO2, No APIO Info ]
    { This CF had many badsectors so that could be the reason
      for large diffs in speed  between different levels }
    At BlockDev => 5.35-5.58 MB/Sec [4.00 MB/Sec]
    At FatFS    => 4.38-4.40 MB/Sec (4MB databuffer) [3.48 MB/Sec]
                   2.63-2.64 MB/Sec (1MB databuffer) [2.23 MB/Sec]
  * For <Transcend 256MB CF> [ PIO2, No APIO Info ]
    { FatFS level used 60MB Fragmented file }
    At BlockDev => 5.35-5.50 MB/Sec
    At FatFS    => 5.08-5.18 MB/Sec (4MB databuffer)
                   4.22-4.25 MB/Sec (1MB databuffer)
  * For <Kingston 256MB CF> [ PIO1, No APIO Info ]
    { FatFS level used 7MB contiguous file }
    At BlockDev => 3.20 MB/Sec []
    At FatFS    => 2.66-3.00 MB/Sec (4MB databuffer)
                   2.66 MB/Sec      (1MB databuffer)
                   2.38-2.66 MB/Sec (256KB databuffer)
  * For <Sandisk 64MB CF> [ PIO1, No APIO Info ] >> SLOWEST FOUND TILL DATE <<
    { FatFS level used 8MB contiguous file }
    At BlockDev => 1.96-1.99 MB/Sec []
    At FatFs    => 1.61-1.80 MB/Sec (4MB databuffer) []
                   1.52-1.68 MB/Sec (1MB databuffer) []
                   ~same as above   (512KB databuffer) []
* Added support for extracting file to Standard Output in fileExtract menu
  if STDOUT is specified as the destination file. During this process
  found that the DM270 target uart seems to be lossing characters 
  once in a while.
* Added logic to calculate SIMPLE CHECKSUM of files either in the normal
  system filesystem or my fatfs filesystem.
  ON VERIFYING THE DATA INTEGRITY OF THE FILES READ USING FATFS AND
  FAST READ LOGIC BASED CF DRIVER of BDHDD.X, IT WAS FOUND THAT THERE IS 
  NO CORRUPTION OF DATA EVEN AT HIGH SPEEDS. THATS COOL.
* FIXME: Found that the reset logic is hanging on DM270 CFs, to verify
  as to where and fix it later.

04Nov2004, 05Nov2004-0100
* Note that the <Sandisk 1GB CF>, <Transcend 512MB CF> and 
  <Transcend 256MB CF> support upto PIO2 mode. 
  While the <Kingston 256MB CF> supports only upto PIO1.
  So the speed difference among them below
* Based on the profiles done as mentioned below EMIF CF Cycle times updated to
  **** EMIF CF Cycle time => 0x0c0d 0x0401 0x1110 ****
  * For <Sandisk 1GB CF>
    { Taking lower values got, as timing is sensitive and stopwatch manual }
    BlockDev level => 6.45MB/Sec [4.25 MB/Sec]
    FatFS level => 6.20MB/Sec (4MB databuffer) [4.00 MB/Sec]
                   5.00MB/Sec (1MB databuffer) [3.48 MB/Sec]
  * For <Transcend 512MB CF>
    BlockDev Level => 5.45MB/Sec [4.00 MB/Sec]
    FatFS level => 4.37MB/Sec (4MB databuffer) [3.48 MB/Sec]
                   2.63MB/Sec (1MB databuffer) [2.23 MB/Sec]
  * For <Transcend 256MB CF>
    BlockDev Level => 5.42MB/Sec
    FatFS level => 5.00MB/Sec (59MB FRAGMENTED file, 4MB databuffer) 
                   4.20MB/Sec (59MB FRAGMENTED file, 1MB databuffer) 
  * For <Kingston 256MB CF>
    BlockDev Level => 3.23MB/Sec
    FatFS level => 2.80MB/Sec Avg (4MB & 7MB files, 4MB databuffer)

  Note: For Small files the speed during 1MB databuffer tends toward 
        4MB Databuffer Speeds
  Note: In above data [xxxxx MB/Sec] corresponds to default EMIFCF CycleTimings

* Updated bdhdd.x logic such that the DM270CF logic is added
  only if PRG_MODE_DM270 is defined
* Made the Databufsize in the testfat.c definable for a given run
  of the prg within a set max limit. Useful for testing effect of
  Databuf size on speeds achieved.
* Profiled Data on DM270
  **** EMIF CF Cycle time => 0x0c0d 0x0901 0x1110 ****
  **** 160MB contiguous file (fatfs) and 40MB contiguous (blockdev) ****
  * For <Transcend 512MB CF>
    BlockDev Level => 5.14MB/Sec
    FatFS level => 4.11MB/Sec (4MB databuffer)
                   3.40MB/Sec (2MB databuffer)
                   2.53MB/Sec (1MB databuffer)
  * For <Sandisk 1GB CF> 
    { Taking lower values got, as timing is sensitive and stopwatch manual }
    BlockDev Level => 5.89MB/Sec
    FatFS level => 5.57MB/Sec (4MB databuffer)
                   5.23MB/Sec (2MB databuffer)
                   4.60MB/Sec (1MB databuffer)

  **** EMIF CF Cycle time => 0x1213 0x0f07 0x1110 ****
  **** 160MB contiguous file (fatfs) and 40MB contiguous (blockdev) ****
  * For <Transcend 512MB CF>
    BlockDev Level => 4.36MB/Sec
    FatFS level => 3.61MB/Sec (4MB databuffer)
                   3.04MB/Sec (2MB databuffer)
                   2.32MB/Sec (1MB databuffer)
                   1.50MB/Sec (512KB databuffer)
  * For <Sandisk 1GB CF>
    BlockDev Level => 4.65MB/Sec
    FatFS level => 4.42MB/Sec (4MB databuffer)
                   4.18MB/Sec (2MB databuffer)
                   3.77MB/Sec (1MB databuffer)

  **** Default EMIF CF Cycle time => 0x1415 0x1109 0x1220 ****
  **** 160MB contiguous file (fatfs) and 40MB contiguous (blockdev) ****
  * For <Sandisk 1GB CF>
    BlockDev Level => 4.25MB/Sec
    FatFS level => 4.00MB/Sec (4MB databuffer)
                   3.80MB/Sec (2MB databuffer)
                   3.48MB/Sec (1MB databuffer)
                   2.96MB/Sec (512KB databuffer)
 

03Nov2004-2350
* Added support for DM270 EMIF DMA between CF and SDRam
  Now getting on the Transcend 512MB CF
  at BlockDev level => 4MB/Sec (40MB contiguous data)
  at FatFS level => 3.48MB/Sec (160MB contiguous file and 4MB Databuffer)
                    2.89MB/Sec (2MB Databuffer)
                    2.23MB/Sec (1MB Databuffer)
  * Also enable compiler optimization, which would have helped 3 to 5 %
* DANGER: This seems better than the bootloader level and PrKernel level
  for FPMC and or Board24 or Board24MNC. HAVE TO VERIFY INTEGRITY of DATA READ.
  As of know ASSUMING INTEGRITY as Directory contents seem to be proper and 
  also as CFRDY is being checked by DM270 before accesing CF.

03Nov2004
* Added support for DM270 CF access
  * unrolling loop as helped speed here
  * Passing larger buffer to fatfs for reading file improved speed
  * declared some functions as inline, seems to have improved speed 
* Cleaned up code, which was already clean
* ON DM270 CF access (PIO mode, no 270 DMA, unrolled loop)
  <Using Transcend 512MB CF>
  Blockdev level speed = 1.48MB/Sec (40MB contiguous read to same buffer)
  For 160MB file (almost contiguous) read to same buffer of size
    4MB databuffer   => readspeed=1.32MB/Sec 
    3MB databuffer   => readspeed=1.28MB/Sec (vaguely remember, to retest)
    2MB databuffer   => readspeed=1.18MB/Sec 
    640KB databuffer => readspeed=810KB/Sec
* TOTRY to improve DM270 CF Speed
  * Use EMIF DMA to transfer data from CF to Memory instead of ARM.
    Note this is still PIO Mode as far as CF is concerned.
  * Currently using Default CS1 timings and explicit wait for CFRDY
    have to see if reducing cycle time helps get data without corruption
    * Also couple this with Changing PIO mode used for CF using SETFEATURE
  * Maybe move to kernel space (may not help much, as already 
    realtime scheduled)
* FIXME:
  * Found some issue with only chdir for some directories once in a while
    have to verify if reproducable on PC. Maybe some issue with FATUC
    logic have to verify

27Oct2004
* Made the blockdevices' setup routine to take a bdkT * as input and
  initialize its member rather than the previous predefined bdkT
  variable. Thus allowing more than one blockdev of a given type
  to be used at the same type.

InBetween
* porta library has been updated as part of another work
  
18Oct2004
* Added support for set features, but disabled by default
  Not much use on PC as the ioport access in the PC architecture
  is limiting the speed achieved to somewhere between PIO0 and PIO1.
  This PC HDD access speed can be improved a LOT, BUT would require
  motherboard chipset specific setting of bus cycles for IDE.
* Reduced the time the bdhdd.x waits after issuing a command
  before checking for BSY bit and other bits to around 500ns
  The spec talks about 400ns. But just in case
* Added ERROR_FATFS_NOTBOOTSEC 

15Oct2004
* Added support for READMULTIPLE logic in bdhdd.x and bdk.h
* More IDENTIFY DEVICE values displayed
* Added Realtime scheduling support for testfat.
  This has improved speed by 40-50%. 
  Previously getting around 2.xMBytesPerSec for bdhdd
  Now getting around 3 MBytesPerSec for bdhdd
* Added a new get_sectors_benchmark function for BlockDevs
  bdfile makes it NULL, where as bdhdd.x provides a modified get_sectors
  to get_sectors_benchmark where the dest buffer pointer is reset to
  begining of buffer after each sector is read. Thus one requires 
  a buffer of only 512 bytes irrespective of the number of sectors
  read during benchmarking

14Oct2004
* Added a option to partk_get to force interpretting a sector as MBR
  irrespective of it finds valid signatures or not.
  Useful if there are bootloaders like grub,etc in the MBR.
* fatfs bootsectorload logic updated to check for fatfs's usual
  bootsector signature in the first byte.
* testfat now allows user to 
  * force a BlockDev reset at the begining
  * force MBR interpretation by partk_get logic
* bdhdd as unrolled loop for get_sectors
* Updated utilsporta to support char16 strings required for FatFS LFN
* Updated fatfs.getfileinfo to work with both char and char16 string
  by passing useLFN flag as required. 
  fatuc uses 8.3 filename for its operations for now.
  Testfat prg also updated. Use 8.3 filenames as it cann't accept
  filenames with space in them for now.
  This required as many windows VFAT volumes don't have LFN entries
  for filenames which fit within 8.3
* testfat added a readspeed test function which reads from fatfs file
  into memory


12Oct2004
* Added logic to simulate error in loadfat for PARTLYMAPPEDFAT logic
  This inturn will lead to wrong sector number being passed to BlockDev
* Before a cmd is sent to HDD, its checked that BSY or ERR or DRQ bits
  aren't set. However if they are set then SRST (softreset) is used
  to recover the situation if possible.
* Softreset added for bdks
  bdhdd.x uses this.
  bdfile.x makes this a dummy.
  testfat provides option to call it explicitly if required.
* bdfile.x 64bit seek added for large filesystems

11Oct2004
* Support for Mapping FAT into memory in parts as required has been added
  Now there are two FAT loading logic
  * Fully Mapped and * Partly Mapped (Usefull for those large FAT32 FATS)
* bdhdd.x uses altstat register to poll status changes and once found
  reads the status register to inform h/w about host having noticed
  the status change.
  Verification of DRQ during each word transfer (if explicitly forced)
  has been removed
* Check for MBR Startbyte signature as been made optional in partk_get
  cas many mbr's which don't have a load code (or which don't take part
  in bootstrapping of OS) don't have this signature, as its part of the
  load code instructions.
* bdhdd.x cleanup and better error notification
  Also increase in wait counts
* partk_get distinguishes between other errors and NO MBR error
  mount inturn uses this info to decide as to fail or continue
  

10Oct2004
* Made bdhdd.x generic such that it can work with either ide0 or ide1
* bdhdd.x has timeout logic now when waiting for bits to be set or cleared
  Plus few others make it better prepared to handle errors during device
  access
* bdkT maintains 
  * grpId and devId, which
    * bdhdd.x uses for ide0/1 and dev0/1
    * bdfile.x ignores
    fsutils and testfat updated to handle these ids.
  * CMDBR and CNTBR for bdhdd.x for now

09Oct2004
* Found that READSECTORSWITHOUTRETRIES (0x21) not supported
* Also signature in LBAlow, LBAMid, LBAHigh, DEVLBA24, SECCNT not set
  for IDENTIFYDEVICE in Bochs, VMWare
* Updated get_sector logic such that it supports multiple sectors to be 
  read properly even if it exceeds 256 sectors.
  However currently it doesn't handle errors or buggy hardware properly

08Oct2004
* Initial support for get_sector, a simple mistake in code debugged

07Oct2004
* Started preliminary support for PC based HDD (bdhdd.x)
  This is a rewrite of my older libata library and uses LBA
  mode for access compared to CHS based access of libata.

05Oct2004
* Added function pointers to TFat structure so that during fatfs_init
  Proper functions are assigned to these pointers depending on the
  FATFS type i.e 12 or 16 or 32. And thus other parts of the fatfs
  logic are not required to bother about the fatfs type. This is
  the best flexible mechanism that can be put in place other than
  having seperate hardcoded fat12/fat16/fat32 type functions.
  * The low level functions are
    * Loading root dir 
    * Getting a Fat Entry
      * FIXME: In future we can make the FAT table handling flexible
        i.e Either Full FAT table could be in Memory or we could load
	parts of FAT Table as required by updating this function.
        - FIXED around 11Oct2004
  * Updated other parts so that they use this mechanism
* Added support to check BlockDev sector size matches FatFS sector size
* Partiton or Physical volume size is embedded in TFat structure and 
  verified to see that FatFS bootsector doesn't tell that FatFS exceeds
  this.
* active Fat Table is identified for Fat16(implicitly 0) and Fat32(extflags)
* Added support for Fat32 read, directory listing, chdir etc except 
  Write operations(same status as Fat16).  Achieved by providing support 
  for fatfs32_getfatentry and fatfs32_loadrootdir, using simplified 
  generalized mechanism added today.
* Logic to autodetect possible Fat32 FS in a small volume suitable for
  Fat12 or Fat16 added.
* Check for and avoid working on Volume with DiskI/O error during last mount
  or Volume which wasn't Cleanly shut.

04Oct2004
* cycle to stars continues
* Removed the nonportable but fast macros for accessing members 
  of the bootsector.
  These are nonportable as there are fields with wrong alignment (based on
  field size) which processors like ARM/Mips don't support in h/w but would
  require s/w support in OS.
* Partition logic identifies if it has a MBR at hand
  Also it uses a buffer passed to it to read the 0th sector into.
* explicit mount and umount logic functions added

30Sep2004
* Incorporated new porta libraries into fatfs
* Made blockdev data and routines into a structure so that it can be
  embedded into Fat structure. Also now a given Fat system could be in 
  any among the many blockdevs in the system.

22july2004
* Made testfat functions use uc pointer as one of their arguments.
  So that we can test/work with multiple fat filesystems in a given run.


21july2004-2200 (what I remember now)
* Interactive menu added to testfat
* Partition support in loadfile functions (i.e adding used partitions baseSec)
* Updated the logic such that they no longer use global structures instead 
  * all fatfs calls use a TFat structure which inturn gets its buffers
    set from a TFatBuffers structure defined by user.
  * and all fatuc calls use the TFatFsUserContext structure which inturn
    as a pointer to the TFat it is using.


20july2004-2300 (what I remember now)
* Added support for reading files with clusSize granularity (loadfileclus).
  Also a separate function is provided so that the application can verify 
  if the buffer it has is ok with this loadfileclus function.
* Added some utility functions for strcpy, memcpy, token parsing
* current path string is maintained in UserContext
* each logic of testfat is timed with added helper routines
* File extraction logic added to testfat
* new dirlisting (inefficient(toShowOthersHowItCouldBe)) logic added



